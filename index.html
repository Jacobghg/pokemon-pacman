

<head>
	<title>Pokemon Pacman Game</title>
	<meta charset="UTF-8">
</head>
<body>
<br>
<canvas id="myCanvas" width="500" height="910" style="border:1px solid #cccccc;"></canvas>

<script type="text/javascript">
    console.log("Script loaded and executing");


    class Sprite {
    constructor(x, y, width, height, imageUrl) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.image = new Image();
        this.loaded = false;

        if (imageUrl) {
            this.setImage(imageUrl);
        }
    }

    setImage(imageUrl) {
        this.image.onload = () => {
            this.loaded = true;
        };
        this.image.src = imageUrl;
    }

    draw(ctx) {
        if (this.loaded) {
            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        }
    }

	isPacman() {
        return false;
    }

    isGhost() {
        return false;
    }

    isPellet() {
        return false;
    }

    isFruit() {
        return false;
    }

    isWall() {
        return false;
    }

    isMoving() {
        return false;
    }
}


class Wall extends Sprite
{
	constructor(x, y, width, height, imageUrl) {
        super(x, y, width, height, imageUrl);
    }

    draw(ctx) {
        if (this.loaded) {
            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        }
    }
}




class Model
{
	constructor() {
        this.sprites = [];
		this.addSprites = [];
        this.removeSprites = [];
        this.loadGame();
		this.pacman = new Pacman(35, 35, 40, 'pokemonImages/pokemon1.png');
        this.sprites.push(this.pacman);
    }

	doesCollide(a, b) {
        // Check if one sprite is completely to the left of the other
        if (a.x + a.width < b.x) {
            return false;
        }

        // Check if one sprite is completely to the right of the other
        if (a.x > b.x + b.width) {
            return false;
        }

        // Check if one sprite is completely above the other
        if (a.y + a.height < b.y) {
            return false;
        }

        // Check if one sprite is completely below the other
        if (a.y > b.y + b.height) {
            return false;
        }

        // If none of the above, they are colliding
        console.log("Collision Detection");
        return true;
    }

    

    loadGame() {
        const wallsData = [
    { x: 0, y: 20, w: 20, h: 20 },
    { x: 0, y: 0, w: 20, h: 20 },
    { x: 0, y: 40, w: 20, h: 20 },
    { x: 0, y: 60, w: 20, h: 20 },
    { x: 0, y: 140, w: 20, h: 20 },
    { x: 0, y: 160, w: 20, h: 20 },
    { x: 0, y: 180, w: 20, h: 20 },
    { x: 0, y: 280, w: 20, h: 20 },
    { x: 0, y: 260, w: 20, h: 20 },
    { x: 0, y: 300, w: 20, h: 20 },
    { x: 0, y: 320, w: 20, h: 20 },
    { x: 0, y: 340, w: 20, h: 20 },
    { x: 0, y: 420, w: 20, h: 20 },
    { x: 0, y: 440, w: 20, h: 20 },
    { x: 0, y: 460, w: 20, h: 20 },
    { x: 20, y: 460, w: 20, h: 20 },
    { x: 40, y: 460, w: 20, h: 20 },
    { x: 120, y: 460, w: 20, h: 20 },
    { x: 140, y: 460, w: 20, h: 20 },
    { x: 180, y: 460, w: 20, h: 20 },
    { x: 160, y: 460, w: 20, h: 20 },
    { x: 280, y: 460, w: 20, h: 20 },
    { x: 280, y: 460, w: 20, h: 20 },
    { x: 320, y: 460, w: 20, h: 20 },
    { x: 300, y: 460, w: 20, h: 20 },
    { x: 340, y: 460, w: 20, h: 20 },
    { x: 420, y: 460, w: 20, h: 20 },
    { x: 460, y: 460, w: 20, h: 20 },
    { x: 440, y: 460, w: 20, h: 20 },
    { x: 480, y: 460, w: 20, h: 20 },
    { x: 480, y: 440, w: 20, h: 20 },
    { x: 480, y: 420, w: 20, h: 20 },
    { x: 480, y: 340, w: 20, h: 20 },
    { x: 480, y: 320, w: 20, h: 20 },
    { x: 480, y: 300, w: 20, h: 20, },
    { x: 480, y: 280, w: 20, h: 20 },
    { x: 480, y: 180, w: 20, h: 20 },
    { x: 480, y: 160, w: 20, h: 20 },
    { x: 480, y: 60, w: 20, h: 20 },
    { x: 480, y: 40, w: 20, h: 20 },
    { x: 480, y: 0, w: 20, h: 20 },
    { x: 480, y: 20, w: 20, h: 20 },
    { x: 400, y: 0, w: 20, h: 20 },
    { x: 380, y: 0, w: 20, h: 20 },
    { x: 360, y: 0, w: 20, h: 20 },
    { x: 340, y: 0, w: 20, h: 20 },
    { x: 260, y: 0, w: 20, h: 20 },
    { x: 240, y: 0, w: 20, h: 20 },
    { x: 220, y: 0, w: 20, h: 20 },
    { x: 200, y: 0, w: 20, h: 20 },
    { x: 120, y: 0, w: 20, h: 20 },
    { x: 100, y: 0, w: 20, h: 20 },
    { x: 80, y: 0, w: 20, h: 20 },
    { x: 80, y: 80, w: 20, h: 20 },
    { x: 100, y: 80, w: 20, h: 20 },
    { x: 120, y: 80, w: 20, h: 20 },
    { x: 340, y: 80, w: 20, h: 20 },
    { x: 360, y: 80, w: 20, h: 20 },
    { x: 380, y: 80, w: 20, h: 20 },
    { x: 400, y: 80, w: 20, h: 20 },
    { x: 220, y: 80, w: 20, h: 20 },
    { x: 220, y: 80, w: 20, h: 20 },
    { x: 200, y: 80, w: 20, h: 20 },
    { x: 240, y: 80, w: 20, h: 20 },
    { x: 280, y: 80, w: 20, h: 20 },
    { x: 260, y: 80, w: 20, h: 20 },
    { x: 240, y: 100, w: 20, h: 20 },
    { x: 240, y: 120, w: 20, h: 20 },
    { x: 200, y: 180, w: 20, h: 20 },
    { x: 220, y: 180, w: 20, h: 20 },
    { x: 200, y: 220, w: 20, h: 20 },
    { x: 200, y: 200, w: 20, h: 20 },
    { x: 200, y: 240, w: 20, h: 20 },
    { x: 220, y: 240, w: 20, h: 20 },
    { x: 240, y: 240, w: 20, h: 20 },
    { x: 260, y: 240, w: 20, h: 20 },
    { x: 300, y: 240, w: 20, h: 20 },
    { x: 280, y: 240, w: 20, h: 20 },
    { x: 300, y: 220, w: 20, h: 20 },
    { x: 300, y: 200, w: 20, h: 20 },
    { x: 300, y: 200, w: 20, h: 20 },
    { x: 300, y: 180, w: 20, h: 20 },
    { x: 280, y: 180, w: 20, h: 20 },
    { x: 380, y: 180, w: 20, h: 20 },
    { x: 380, y: 220, w: 20, h: 20 },
    { x: 380, y: 220, w: 20, h: 20 },
    { x: 380, y: 220, w: 20, h: 20 },
    { x: 380, y: 200, w: 20, h: 20 },
    { x: 380, y: 260, w: 20, h: 20 },
    { x: 380, y: 240, w: 20, h: 20 },
    { x: 400, y: 220, w: 20, h: 20 },
    { x: 420, y: 220, w: 20, h: 20 },
    { x: 120, y: 180, w: 20, h: 20 },
    { x: 120, y: 200, w: 20, h: 20 },
    { x: 120, y: 220, w: 20, h: 20 },
    { x: 120, y: 260, w: 20, h: 20 },
    { x: 120, y: 240, w: 20, h: 20 },
    { x: 100, y: 220, w: 20, h: 20 },
    { x: 100, y: 220, w: 20, h: 20 },
    { x: 100, y: 220, w: 20, h: 20 },
    { x: 80, y: 220, w: 20, h: 20 },
    { x: 200, y: 300, w: 20, h: 20 },
    { x: 240, y: 300, w: 20, h: 20 },
    { x: 220, y: 300, w: 20, h: 20 },
    { x: 260, y: 300, w: 20, h: 20 },
    { x: 280, y: 300, w: 20, h: 20 },
    { x: 300, y: 300, w: 20, h: 20 },
    { x: 260, y: 320, w: 20, h: 20 },
    { x: 260, y: 340, w: 20, h: 20 },
    { x: 320, y: 300, w: 20, h: 20 },
    { x: 260, y: 360, w: 20, h: 20 },
    { x: 60, y: 380, w: 20, h: 20 },
    { x: 80, y: 380, w: 20, h: 20 },
    { x: 100, y: 380, w: 20, h: 20 },
    { x: 100, y: 400, w: 20, h: 20 },
    { x: 100, y: 420, w: 20, h: 20 },
    { x: 420, y: 380, w: 20, h: 20 },
    { x: 420, y: 380, w: 20, h: 20 },
    { x: 440, y: 380, w: 20, h: 20 },
    { x: 420, y: 380, w: 20, h: 20 },
    { x: 420, y: 380, w: 20, h: 20 },
    { x: 420, y: 380, w: 20, h: 20 },
    { x: 420, y: 380, w: 20, h: 20 },
    { x: 420, y: 380, w: 20, h: 20 },
    { x: 420, y: 380, w: 20, h: 20 },
    { x: 400, y: 380, w: 20, h: 20 },
    { x: 400, y: 400, w: 20, h: 20 },
    { x: 400, y: 420, w: 20, h: 20 },
    { x: 160, y: 400, w: 20, h: 20 },
    { x: 160, y: 420, w: 20, h: 20 },
    { x: 180, y: 400, w: 20, h: 20 },
    { x: 180, y: 420, w: 20, h: 20 },
    { x: 300, y: 420, w: 20, h: 20 },
    { x: 300, y: 420, w: 20, h: 20 },
    { x: 300, y: 400, w: 20, h: 20 },
    { x: 320, y: 400, w: 20, h: 20 },
    { x: 320, y: 420, w: 20, h: 20 },
    { x: 100, y: 320, w: 20, h: 20 },
    { x: 120, y: 320, w: 20, h: 20 },
    { x: 380, y: 320, w: 20, h: 20 },
    { x: 400, y: 320, w: 20, h: 20 },
    { x: 0, y: 560, w: 20, h: 20 },
    { x: 0, y: 560, w: 20, h: 20 },
    { x: 0, y: 540, w: 20, h: 20 },
    { x: 0, y: 520, w: 20, h: 20 },
    { x: 0, y: 580, w: 20, h: 20 },
    { x: 0, y: 600, w: 20, h: 20 },
    { x: 60, y: 560, w: 20, h: 20 },
    { x: 60, y: 600, w: 20, h: 20 },
    { x: 100, y: 580, w: 20, h: 20 },
    { x: 100, y: 580, w: 20, h: 20 },
    { x: 100, y: 600, w: 20, h: 20 },
    { x: 100, y: 560, w: 20, h: 20 },
    { x: 100, y: 560, w: 20, h: 20 },
    { x: 100, y: 560, w: 20, h: 20 },
    { x: 60, y: 580, w: 20, h: 20 },
    { x: 80, y: 580, w: 20, h: 20 },
    { x: 180, y: 600, w: 20, h: 20 },
    { x: 200, y: 600, w: 20, h: 20 },
    { x: 220, y: 580, w: 20, h: 20 },
    { x: 220, y: 580, w: 20, h: 20 },
    { x: 200, y: 580, w: 20, h: 20 },
    { x: 220, y: 560, w: 20, h: 20 },
    { x: 240, y: 580, w: 20, h: 20 },
    { x: 240, y: 560, w: 20, h: 20 },
    { x: 240, y: 560, w: 20, h: 20 },
    { x: 240, y: 540, w: 20, h: 20 },
    { x: 260, y: 580, w: 20, h: 20 },
    { x: 260, y: 560, w: 20, h: 20 },
    { x: 280, y: 600, w: 20, h: 20 },
    { x: 280, y: 580, w: 20, h: 20 },
    { x: 300, y: 600, w: 20, h: 20 },
    { x: 480, y: 520, w: 20, h: 20 },
    { x: 480, y: 540, w: 20, h: 20 },
    { x: 480, y: 580, w: 20, h: 20 },
    { x: 480, y: 560, w: 20, h: 20 },
    { x: 480, y: 600, w: 20, h: 20 },
    { x: 100, y: 660, w: 20, h: 20 },
    { x: 80, y: 660, w: 20, h: 20 },
    { x: 120, y: 680, w: 20, h: 20 },
    { x: 120, y: 660, w: 20, h: 20 },
    { x: 120, y: 700, w: 20, h: 20 },
    { x: 380, y: 660, w: 20, h: 20 },
    { x: 380, y: 660, w: 20, h: 20 },
    { x: 380, y: 660, w: 20, h: 20 },
    { x: 360, y: 660, w: 20, h: 20 },
    { x: 360, y: 660, w: 20, h: 20 },
    { x: 360, y: 660, w: 20, h: 20 },
    { x: 340, y: 660, w: 20, h: 20 },
    { x: 340, y: 680, w: 20, h: 20 },
    { x: 340, y: 700, w: 20, h: 20 },
    { x: 420, y: 560, w: 20, h: 20 },
    { x: 420, y: 600, w: 20, h: 20 },
    { x: 420, y: 580, w: 20, h: 20 },
    { x: 400, y: 580, w: 20, h: 20 },
    { x: 380, y: 560, w: 20, h: 20 },
    { x: 380, y: 580, w: 20, h: 20 },
    { x: 380, y: 600, w: 20, h: 20 },
    { x: 200, y: 700, w: 20, h: 20 },
    { x: 220, y: 680, w: 20, h: 20 },
    { x: 240, y: 660, w: 20, h: 20 },
    { x: 260, y: 680, w: 20, h: 20 },
    { x: 280, y: 700, w: 20, h: 20 },
    { x: 240, y: 700, w: 20, h: 20 },
    { x: 240, y: 680, w: 20, h: 20 },
    { x: 260, y: 700, w: 20, h: 20 },
    { x: 220, y: 700, w: 20, h: 20 },
    { x: 480, y: 660, w: 20, h: 20 },
    { x: 480, y: 680, w: 20, h: 20 },
    { x: 480, y: 720, w: 20, h: 20 },
    { x: 480, y: 700, w: 20, h: 20 },
    { x: 0, y: 660, w: 20, h: 20 },
    { x: 0, y: 680, w: 20, h: 20 },
    { x: 0, y: 700, w: 20, h: 20 },
    { x: 0, y: 720, w: 20, h: 20 },
    { x: 180, y: 780, w: 20, h: 20 },
    { x: 200, y: 780, w: 20, h: 20 },
    { x: 240, y: 780, w: 20, h: 20 },
    { x: 220, y: 780, w: 20, h: 20 },
    { x: 260, y: 780, w: 20, h: 20 },
    { x: 300, y: 780, w: 20, h: 20 },
    { x: 280, y: 780, w: 20, h: 20 },
    { x: 300, y: 800, w: 20, h: 20 },
    { x: 300, y: 820, w: 20, h: 20 },
    { x: 300, y: 840, w: 20, h: 20 },
    { x: 180, y: 800, w: 20, h: 20 },
    { x: 180, y: 840, w: 20, h: 20 },
    { x: 180, y: 820, w: 20, h: 20 },
    { x: 200, y: 840, w: 20, h: 20 },
    { x: 300, y: 840, w: 20, h: 20 },
    { x: 280, y: 840, w: 20, h: 20 },
    { x: 400, y: 780, w: 20, h: 20 },
    { x: 400, y: 800,w: 20, h: 20 },
    { x: 420, y: 780, w: 20, h: 20 },
    { x: 420, y: 800, w: 20, h: 20 },
    { x: 60, y: 780, w: 20, h: 20 },
    { x: 80, y: 780, w: 20, h: 20 },
    { x: 60, y: 800, w: 20, h: 20 },
    { x: 80, y: 800, w: 20, h: 20 },
    { x: 0, y: 840, w: 20, h: 20 },
    { x: 480, y: 840, w: 20, h: 20 },
    { x: 480, y: 820, w: 20, h: 20 },
    { x: 480, y: 800, w: 20, h: 20 },
    { x: 0, y: 820, w: 20, h: 20 },
    { x: 0, y: 800, w: 20, h: 20 },
    { x: 480, y: 860, w: 20, h: 20 },
    { x: 480, y: 880, w: 20, h: 20 },
    { x: 360, y: 880, w: 20, h: 20 },
    { x: 0, y: 880, w: 20, h: 20 },
    { x: 0, y: 860, w: 20, h: 20 },
    { x: 120, y: 880, w: 20, h: 20 },
    { x: 120, y: 880, w: 20, h: 20 },
    { x: 120, y: 880, w: 20, h: 20 },
    { x: 120, y: 880, w: 20, h: 20 },
    { x: 100, y: 880, w: 20, h: 20 },
    { x: 220, y: 880, w: 20, h: 20 },
    { x: 240, y: 880, w: 20, h: 20 },
    { x: 260, y: 880, w: 20, h: 20 },
    { x: 220, y: 880, w: 20, h: 20 },
    { x: 220, y: 880, w: 20, h: 20 },
    { x: 200, y: 880, w: 20, h: 20 },
    { x: 380, y: 880, w: 20, h: 20 },
    { x: 400, y: 880, w: 20, h: 20 },
    { x: 480, y: 140, w: 20, h: 20 },
    { x: 480, y: 260, w: 20, h: 20 },
  ];

  const fruitPositions = [
    { x: 60, y: 100, index: 1 },
    { x: 120, y: 150, index: 2 },
    { x: 160, y: 200, index: 3 },
    { x: 30, y: 350, index: 6 },
    { x: 440, y: 400, index: 7 },
    { x: 400, y: 150, index: 1 },
    { x: 420, y: 180, index: 2 },
    { x: 340, y: 250, index: 3 },
    { x: 240, y: 150, index: 5 },
    { x: 180, y: 100, index: 6 },
    { x: 120, y: 50, index: 7 },
    { x: 60, y: 350, index: 1 },
    { x: 60, y: 400, index: 2 },
    { x: 240, y: 750, index: 4 },
    { x: 240, y: 720, index: 5 },
    { x: 300, y: 650, index: 6 },
    { x: 360, y: 750, index: 7 },
    { x: 180, y: 650, index: 1 },
    { x: 120, y: 750, index: 2 },
    { x: 60, y: 700, index: 3 },
    { x: 330, y: 800, index: 4 },
    { x: 360, y: 850, index: 5 },
    { x: 420, y: 830, index: 6 },
    { x: 140, y: 850, index: 7 },
    ];

    const ghostPositions = [
        { x: 45, y: 45, index: 1 },       
    ];

  



    wallsData.forEach(wall => {
            this.sprites.push(new Wall(wall.x, wall.y, wall.w, wall.h, 'wall.png'));
            console.log(`Added wall at position (${wall.x}, ${wall.y}) with dimensions (${wall.w}, ${wall.h})`);
        });

        // Add fruits to the sprites array
        fruitPositions.forEach((pos, index) => {
            let imageIndex = (index % 7) + 1; // Ensure index is between 1 and 7
            this.sprites.push(new Fruit(pos.x, pos.y, imageIndex));
        });

        // Add ghosts to the sprites array
        ghostPositions.forEach((pos, index) => {
            let imageIndex = (index % 8) + 1; // Ensure index is between 1 and 8
            let newGhost = new Ghost(pos.x, pos.y, imageIndex);

            // Check for collision with walls
            let collision = this.sprites.some(sprite => {
                if (sprite instanceof Wall) {
                    return newGhost.x < sprite.x + sprite.width &&
                           newGhost.x + newGhost.width > sprite.x &&
                           newGhost.y < sprite.y + sprite.height &&
                           newGhost.y + newGhost.height > sprite.y;
                }
                return false;
            });

            if (!collision) {
                this.sprites.push(newGhost);
            }
        });
    }

    getPacman() {
        return this.pacman; // Returns the Pacman object
    }

   update() {
    // Update all sprites first
    this.sprites.forEach(sprite => {
        if (sprite.update) {
            sprite.update();
        }
    });

    // Now handle collisions
    this.sprites.forEach(sprite1 => {
        this.sprites.forEach(sprite2 => {
            // Avoid self-collision
            if (sprite1 !== sprite2 && this.doesCollide(sprite1, sprite2)) {
                // Handling Pacman and Wall collision
                if (sprite1 instanceof Pacman && sprite2 instanceof Wall) {
                    console.log("Collision detected between Pacman and a wall.");
                    sprite1.getOutOfWall(sprite2);
                }
                // Handling Fruit and Wall collision
                else if (sprite1 instanceof Fruit && sprite2 instanceof Wall) {
                    console.log("Fruit collided with a wall, bouncing off.");
                    sprite1.bounceOffWall();
                }
                // Handling Fruit and Pacman collision
                else if (sprite1 instanceof Fruit && sprite2 instanceof Pacman) {
                    console.log("Pacman eats a fruit.");
                    sprite1.eatFruit();
                }
            }
        });
    });

    // Remove fruits that are not valid anymore (eaten)
    this.sprites = this.sprites.filter(sprite => !(sprite instanceof Fruit && !sprite.isValid));
}

}
							 
							
        

       





class View {
    constructor(model) {
        this.model = model;
        this.canvas = document.getElementById("myCanvas");
        this.ctx = this.canvas.getContext("2d");
        this.ctx.fillStyle = "rgb(48, 25, 52)"; // Using rgb() format for CSS
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); // Draw the rectang}
    }

    update() {
        this.ctx.fillStyle = "rgb(48, 25, 52)"; 
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.model.sprites.forEach(sprite => {
            if (sprite.loaded) {
                sprite.draw(this.ctx);
            }
        });
    }
}

class Pacman extends Sprite {
    constructor(x, y, width, imageUrl) {
		super(x, y, width, width, imageUrl);        this.speed = 5;
        this.direction = 0; // 0=down, 1=left, 2=right, 3=up
        this.moving = false;
        this.pacmanImages = [];
        this.currentImage = 0;
        this.loadImages();
        this.prevX = x;
        this.prevY = y;
    }

    loadImages() {
        for (let i = 1; i <= 12; i++) {
            const img = new Image();
            img.src = `pokemonImages/pokemon${i}.png`;
            img.onload = () => {
                this.pacmanImages[i - 1] = img;
                if (i === 1) {
                    this.image = img;  // Set the first image as the default image
                }
            };
        }
    }

    draw(ctx) {
        // Draw the yellow box first to ensure it always appears
        ctx.fillStyle = 'yellow';
        ctx.fillRect(this.x, this.y, this.width, this.height);

        // Draw the actual image frame on top of the yellow box
        let imageIndex = this.currentImage + this.direction * 3;
        if (this.pacmanImages[imageIndex]) {
            ctx.drawImage(this.pacmanImages[imageIndex], this.x, this.y, this.width, this.height);
        }
    }


    move() {
        if (!this.moving) return;

        this.prevX = this.x;
        this.prevY = this.y;

        switch (this.direction) {
            case 0: this.y += this.speed; break; // Down
            case 1: this.x -= this.speed; break; // Left
            case 2: this.x += this.speed; break; // Right
            case 3: this.y -= this.speed; break; // Up
        }

        // Implement warping logic
        this.checkHorizontalWarping();
        this.checkVerticalWarping();
    }

	getOutOfWall(otherSprite) {
    // Right collision (Pacman hits the wall from the left)
    if (this.x + this.width > otherSprite.x && this.prevX + this.width <= otherSprite.x) {
        console.log("Right collision detected.");
        this.x = otherSprite.x - this.width;
    }
    // Left collision (Pacman hits the wall from the right)
    else if (this.x < otherSprite.x + otherSprite.width && this.prevX >= otherSprite.x + otherSprite.width) {
        console.log("Left collision detected.");
        this.x = otherSprite.x + otherSprite.width;
    }
    // Bottom collision (Pacman hits the wall from above)
    else if (this.y + this.height > otherSprite.y && this.prevY + this.height <= otherSprite.y) {
        console.log("Bottom collision detected.");
        this.y = otherSprite.y - this.height;
    }
    // Top collision (Pacman hits the wall from below)
    else if (this.y < otherSprite.y + otherSprite.height && this.prevY >= otherSprite.y + otherSprite.height) {
        console.log("Top collision detected.");
        this.y = otherSprite.y + otherSprite.height;
    } else {
        // Handle cases where none of the specific conditions are met
        console.log("No specific collision orientation detected.");
    }
    console.log(`Pacman position after collision resolution: (${this.x}, ${this.y})`);
}


    checkHorizontalWarping() {
        const gameWidth = document.getElementById('myCanvas').width;
        if (this.x < 0) {
            this.x = gameWidth - this.width;
        } else if (this.x + this.width > gameWidth) {
            this.x = 0;
        }
    }

    checkVerticalWarping() {
        const gameHeight = document.getElementById('myCanvas').height;
        if (this.y < 0) {
            this.y = gameHeight - this.height;
        } else if (this.y + this.height > gameHeight) {
            this.y = 0;
        }
    }

    updateImageNum() {
        if (this.moving) {
            this.currentImage = (this.currentImage + 1) % 3; // Assumes 3 frames per direction
        }
    }


    setDirection(newDirection) {
        this.direction = newDirection;
        this.moving = true;
    }

    stop() {
        this.moving = false;
        this.currentImage = 0;
    }

    update() {
        this.updateImageNum();  // Update animation frame
        this.move();            // Move if moving
    }

	isPacman() {
		return true;
	}

	isMoving() {
		return true;
	}
}

class Ghost extends Sprite {
    constructor(x, y) {
        super(x, y, 20, 20);
        this.collidedWithPacman = false;
        this.ghostImages = new Array(8); // Ensure array is initialized properly.
        this.deathTimer = 120;
        this.loadImages();
        this.imageIndex = 0; // To manage which ghost image to display
    }

    loadImages() {
    console.log("Starting to load ghost images."); // Initial debug statement to indicate start of loading process
    this.ghostImages = new Array(8); // Explicitly initializing the array here for clarity

    for (let i = 0; i < 8; i++) {
        const img = new Image();
        img.src = `PacmanImages/ghost${i + 1}.png`;
        img.onload = () => {
            this.ghostImages[i] = img; // Set image at index i
            console.log(`Ghost image ${i + 1} loaded successfully and set at index ${i}`); // Debugging output for successful load

            if (i === 0) {
                this.image = img; // Set the first image as the default image
                this.loaded = true;
                console.log("First ghost image set as default and loaded flag set to true"); // Debugging output when the first image is set as default
            }
        };
        img.onerror = () => {
            console.error(`Error loading ghost image: PacmanImages/ghost${i + 1}.png`); // More detailed error handling
        };
    }
    console.log("All ghost images have been initiated for loading."); // Debug statement after setting up all load handlers
}
	


	draw(ctx) {
        if (!this.loaded) return; // Ensure the ghost is not drawn until all images are loaded

        if (!this.collidedWithPacman) {
            this.image = this.ghostImages[0]; // Initial blue state
        } else if (this.deathTimer > 100) {
            this.image = this.ghostImages[1]; // Second blue state
        } else if (this.deathTimer > 80) {
            this.image = this.ghostImages[2]; // White state
        } else if (this.deathTimer > 40) {
            let index = (Math.floor(this.deathTimer / 10) % 4) + 4;
            this.image = this.ghostImages[index]; // Eyes cycling
        } else if (this.deathTimer <= 0) {
            return; // Becomes invisible after death sequence
        }

        if (this.image) {
            console.log(`Drawing image: ${this.image.src}`);
            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        } else {
            console.error('Attempted to draw an undefined image.');
        }
    }


    update() {
        if (this.collidedWithPacman) {
            this.deathTimer--; // Decrement only after collision
            if (this.deathTimer <= 0) {
                this.collidedWithPacman = false; // Reset collision state for rebirth or removal
            }
        }
    }

    triggerDeathSequence() {
        this.collidedWithPacman = true; // Start the death sequence on collision
    }

    isGhost() {
        return true;
    }

	
}

class Pellet extends Sprite {

}


class Fruit extends Sprite {
    constructor(x, y, index) {
        let imageUrl = `PacmanImages/fruit${index}.png`;
        super(x, y, 25, 25, imageUrl);
        this.isValid = true;
        this.loadImage(index);
        this.dx = 1;
        this.dy = 0;
        this.x = x;
        this.y = y;
        this.isValid = true;
    }

    eatFruit() {
		this.isValid = false;
    }



    loadImage(index) {
    const imageUrl = `PacmanImages/fruit${index}.png`;
    console.log(`Starting to load fruit image from: ${imageUrl}`); // Log the initiation of the loading process
    
    if (!this.image) {
        this.image = new Image();
        console.log("Image object was not initialized, initializing now.");
    } else {
        console.log("Image object is already initialized.");
    }

    this.image.src = imageUrl;
    console.log(`Image source set to: ${imageUrl}`); // Confirm what URL is being set

    this.image.onload = () => {
        this.loaded = true;
        console.log(`Image successfully loaded from: ${imageUrl}`); // Confirm successful load
    };

    this.image.onerror = () => {
        console.error(`Error loading fruit image from: ${imageUrl}`); // Log errors
    };
}



    draw(ctx) {
        if (this.loaded) {
            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        }
    }

    checkHorizontalWarping() {
        const gameWidth = document.getElementById("myCanvas").width;
        if (this.x < 0) {
            this.x = gameWidth - this.width;
        } else if (this.x + this.width > gameWidth) {
            this.x = 0;
        }
    }

	handleCollision(other) {
    if (other.isWall()) {
        console.log("Handling collision with a wall");
        bounceOffWall();
    } else if (other.isPacman()) {
        this.eatFruit();
    }
}
	bounceOffWall() {
        this.dx *= -1;
        this.dy *= -1;
        console.log("Bounced off wall");
    }

    update() {
	    this.x += this.dx;
	    this.y += this.dy;
	    this.checkHorizontalWarping();
	    return true;
	}

	isFruit() {
		return true;
	}
}





class Controller {
    constructor(model, view) {
        this.model = model;
        this.view = view;
        this.keys = { left: false, up: false, right: false, down: false };
		this.editMode = false;
        this.addGhosts = false;
        this.addWalls = false;
        this.removeWalls = false;
        this.addPellets = false;
        this.addFruit = false;

        document.addEventListener('keydown', (e) => this.keyDown(e));
        document.addEventListener('keyup', (e) => this.keyUp(e));
		document.addEventListener('mousedown', (e) => this.mousePressed(e));
        document.addEventListener('mousemove', (e) => this.mouseMove(e));
    }

	keyDown(event) {
        if (event.key === 'e') {
            this.editMode = !this.editMode;
            this.resetAddModes();
        } else if (this.editMode) {
            switch (event.key) {
                case 'g':
                    this.addGhosts = true;
                    this.addWalls = false;
                    this.removeWalls = false;
                    this.addPellets = false;
                    this.addFruit = false;
                    break;
                case 'a':
                    this.addWalls = true;
                    this.addGhosts = false;
                    this.removeWalls = false;
                    this.addPellets = false;
                    this.addFruit = false;
                    break;
                case 'r':
                    this.removeWalls = true;
                    this.addGhosts = false;
                    this.addWalls = false;
                    this.addPellets = false;
                    this.addFruit = false;
                    break;
                case 'p':
                    this.addPellets = true;
                    this.addGhosts = false;
                    this.addWalls = false;
                    this.removeWalls = false;
                    this.addFruit = false;
                    break;
                case 'f':
                    this.addFruit = true;
                    this.addGhosts = false;
                    this.addWalls = false;
                    this.removeWalls = false;
                    this.addPellets = false;
                    break;
            }
        }
    }

    keyUp(event) {
        if (this.editMode) {
            switch (event.key) {
                case 'g':
                case 'a':
                case 'r':
                case 'p':
                case 'f':
                    this.resetAddModes();
                    break;
            }
        }
    }

    mousePressed(e) {
    if (this.editMode) {
        const mouseX = e.clientX;
        const mouseY = e.clientY + this.model.getScrollPosY();

        if (!this.removeWalls && !this.addGhosts && !this.addFruit && !this.addPellets) {
            console.log("Start Wall Mode");
            this.model.startWall(mouseX, mouseY);
        } else if (this.removeWalls) {
            console.log("Remove Wall Mode");
            this.model.removeWall(mouseX, mouseY);
        } else if (this.addGhosts) {
            console.log("Add Ghost Mode");
            this.model.addGhost(mouseX, mouseY);
        } else if (this.addFruit) {
            console.log("Add Fruit Mode");
            this.model.addFruit(mouseX, mouseY);
        } else if (this.addPellets) {
            console.log("Add Pellet Mode");
            this.model.addPellet(mouseX, mouseY);
        }

        this.view.repaint(); // Repaint the view to reflect changes
    } else {
        console.log("Edit mode is off");
    }
}



    mouseMove(event) {
        // Handle mouse movement (if needed)
    }

	resetAddModes() {
        this.addGhosts = false;
        this.addWalls = false;
        this.removeWalls = false;
        this.addPellets = false;
        this.addFruit = false;
    }



    keyDown(event) {
        switch (event.keyCode) {
            case 37: // Left arrow
                this.keys.left = true;
                break;
            case 38: // Up arrow
                this.keys.up = true;
                break;
            case 39: // Right arrow
                this.keys.right = true;
                break;
            case 40: // Down arrow
                this.keys.down = true;
                break;
        }
        this.update();
    }

    keyUp(event) {
        switch (event.keyCode) {
            case 37: // Left arrow
                this.keys.left = false;
                break;
            case 38: // Up arrow
                this.keys.up = false;
                break;
            case 39: // Right arrow
                this.keys.right = false;
                break;
            case 40: // Down arrow
                this.keys.down = false;
                break;
        }
        this.update();
    }

    update() {
        const pacman = this.model.getPacman();
        if (this.keys.left) {
            pacman.setDirection(1);
            pacman.moving = true;
        } else if (this.keys.up) {
            pacman.setDirection(3);
            pacman.moving = true;
        } else if (this.keys.right) {
            pacman.setDirection(2);
            pacman.moving = true;
        } else if (this.keys.down) {
            pacman.setDirection(0);
            pacman.moving = true;
        } else {
            pacman.moving = false;
        }
    }

    
}


   

class Game
{
    static WINDOW_HEIGHT = 500;
	static WINDOW_WIDTH = 500;
	static GAME_HEIGHT = 910;
    static GAME_WIDTH = 500;

	constructor()
	{
		this.model = new Model();
		this.view = new View(this.model, "myCanvas");
		this.controller = new Controller(this.model, this.view);
	}

	onTimer()
	{
		this.controller.update();
		this.model.update();
		this.view.update();
	}
}

let game = new Game();
let timer = setInterval(function() { game.onTimer(); }, 40);

</script>

</body>

